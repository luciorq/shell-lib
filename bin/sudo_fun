#!/usr/bin/env bash

# Do NOT modify this file manually.
# Change source code at: https://github.com/luciorq/shell-lib
# Author: Lucio Rezende Queiroz
# License: MIT

\builtin trap '\builtin echo "Exit status ${?} at line ${LINENO} from: ${BASH_COMMAND}"' ERR

\builtin set -o errexit;    # abort on nonzero exitstatus
\builtin set -o nounset;    # abort on unbound variable
\builtin set -o pipefail;   # do not hide errors within pipes

[[ "${BASH_VERSINFO[0]}" -lt 4 ]] && { \builtin echo >&2 "Error: Bash >=4 required"; \builtin exit 1; }

function sudo_fun ()
{
    builtin local sudo_bin;
    builtin local bash_bin;
    builtin local cmd_str;
    builtin local cmd_type;
    builtin local args_q;
    builtin local args_str;
    builtin local cmd_prep;
    sudo_bin="$(which_bin 'sudo')";
    if [[ -z "${sudo_bin}" ]]; then
        exit_fun "'sudo' is not available ...";
        \builtin exit 1;
    fi;
    if [[ ${#} -eq 0 ]]; then
        "${sudo_bin}";
        \builtin return;
    fi;
    cmd_str="${1:-}";
    if [[ "${cmd_str}" == '--help' ]] || [[ "${cmd_str}" == '-h' ]] || [[ "${cmd_str}" == '-l' ]] || [[ "${cmd_str}" == '--version' ]] || [[ "${cmd_str}" == '-V' ]]; then
        "${sudo_bin}" "${cmd_str}";
        \builtin return;
    fi;
    if [[ -d "${cmd_str}" ]]; then
        exit_fun "'${cmd_str}' is a directory.";
        \builtin exit 1;
    fi;
    bash_bin="$(which_bin 'bash')";
    cmd_prep="shopt -s expand_aliases; _SUDO_FUN=true; TERM=xterm-256color; ";
    declare -a args_q=("${@@Q}");
    args_str="${args_q[*]:1}";
    cmd_type="$(_SUDO_FUN=true "${bash_bin}" -i -c "${cmd_prep} LC_ALL=C \builtin type -t '${cmd_str}';")";
    case "${cmd_type}" in
        file)
            type_str="Normal"
        ;;
        builtin)
            type_str="Shell Builtin"
        ;;
        alias)
            type_str="Alias"
        ;;
        function)
            type_str="Function"
        ;;
        *)
            exit_fun "Unknown command '${cmd_type}' type for '${cmd_str}'.";
            \builtin exit 1
        ;;
    esac;
    \builtin echo -ne "* Command type:\n" 1>&2;
    \builtin echo -ne "\t--> ${type_str}\n" 1>&2;
    "${sudo_bin}" _SUDO_FUN=true "${bash_bin}" -O expand_aliases -i -c "${cmd_prep}eval ${cmd_str} \"${args_str}\"";
    \builtin return 0
}

function exit_fun ()
{
    : builtin local Error && Error=' ' && \builtin unset -v Error && "${Error:?$1}";
    \builtin exit 1
}

function type_str ()
{
    local type_key type_str_arr;
    type_key="$1";
    declare -A type_str_arr=([keyword]="is a shell keyword" [builtin]="is a shell builtin" [alias]="is aliased to" [function]="is a function");
    echo "${type_str_arr["${type_key}"]}";
    return 0
}

function which_bin ()
{
    \builtin local cmd_arg;
    \builtin local path_dir_arr;
    \builtin local path_dir;
    \builtin local file_name;
    \builtin local cmd_bin;
    cmd_arg="${1:-}";
    cmd_bin='';
    IFS=: \builtin read -r -a path_dir_arr <<< "${PATH:-}";
    for path_dir in "${path_dir_arr[@]}";
    do
        file_name="${path_dir}/${cmd_arg}";
        if [[ -x "${file_name}" && ! -d "${file_name}" ]] && [[ "${file_name}" =~ ${cmd_arg}$ ]]; then
            cmd_bin="${file_name}";
            \builtin break;
        fi;
    done;
    \builtin echo -ne "${cmd_bin}";
    \builtin return 0
}

function main () {
    sudo_fun "${@:-}";
    \builtin return;
}

main "${@:-}";
\builtin exit;
